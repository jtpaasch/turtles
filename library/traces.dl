
// =========================================================
// Traces
// =========================================================

.type tid <: number // Trace IDs
.type stg <: number // The stage or index in a trace.
.type act <: symbol // Actions in a trace


// ---------------------------------------------------------
// Actions
// ---------------------------------------------------------

.decl nopActionTag(tag:act)
nopActionTag("nop").

.decl declActionTag(tag:act)
declActionTag("decl").

.decl assignActionTag(tag:act)
assignActionTag("assgn").

.decl trueBranchActionTag(tag:act)
trueBranchActionTag("go-T").

.decl falseBranchActionTag(tag:act)
falseBranchActionTag("go-F").

.decl breakActionTag(tag:act)
breakActionTag("break").

.decl continueActionTag(tag:act)
continueActionTag("continue").

.decl gotoActionTag(tag:act)
gotoActionTag("goto").

.decl initActionTag(tag:act)
initActionTag("init").

.decl initCP(cp:cp)
initCP("-").


.decl declAction(trace:tid,stage:stg,var:ident,addr:addr,val:val)

.decl assignAction(trace:tid,stage:stg,var:ident,addr:addr,val:val)
.decl noAssignAction(trace:tid,stage:stg,var:ident)

.decl trueBranchAction(trace:tid,stage:stg,node:id)
.decl falseBranchAction(trace:tid,stage:stg,node:id)


// ---------------------------------------------------------
// Syntax helpers
// ---------------------------------------------------------

.decl progVar(var:ident)
progVar(V) :- lvalExpr(_,V).

.decl isSkip(node:id)
isSkip(N) :- valueStmt(N,_,E),emptyExpr(E).

.decl isDecl(node:id)
isDecl(N) :- declStmt(N,_,_,_).

.decl isAssignment(node:id)
isAssignment(N) :- valueStmt(N,_,E),assignOpExpr(E,_,_,_).

.decl lhsLvalOf(node:id,var:ident)
lhsLvalOf(N,V) :-
  valueStmt(N,_,E),assignOpExpr(E,_,LHS,_),lvalExpr(LHS,V).

.decl rhsExprOf(node:id,expr:id)
rhsExprOf(N,RHS) :- valueStmt(N,_,E),assignOpExpr(E,_,_,RHS).

.decl declTree(node:id,child:id,leaf:symbol)
declTree(N1,N3,"false"),
declTree(N1,N4,"false") :- declStmt(N1,_,_,N2),declList(N2,N3,N4).

declTree(N1,N3,"false"),
declTree(N1,N4,"false") :- declTree(N1,N2,"false"),declList(N2,N3,N4).

declTree(N1,N2,"true") :- declTree(N1,N2,"false"),varDecl(N2,_,_).

.decl varDeclOf(node:id,var:ident,init:id)
varDeclOf(N,V,N3) :- declTree(N,N2,"true"),varDecl(N2,V,N3).

.decl isInit(node:id)
isInit(N) :- varDeclOf(_,_,N).

.decl declSpecTree(node:id,child:id,leaf:symbol)
declSpecTree(N1,N3,"false"),
declSpecTree(N1,N4,"false") :-
  declStmt(N1,_,N2,_),declSpecList(N2,N3,N4).

declSpecTree(N1,N3,"false"),
declSpecTree(N1,N4,"false") :-
  declSpecTree(N1,N2,"false"),declSpecList(N2,N3,N4).

declSpecTree(N1,N2,"true") :-
  declSpecTree(N1,N2,"false"),simpleTypeSpec(N2,_).

.decl simpleTypeDecl(node:id,typ:typ)
simpleTypeDecl(N,T) :- declSpecTree(N,N2,"true"),simpleTypeSpec(N2,T).

.decl signedInt(typ:typ)
signedInt("int").

.decl unsignedInt(typ:typ)
unsignedInt("unsigned int").

.decl simpleTypeDeclOf(node:id,typ:typ)
simpleTypeDeclOf(N,T) :-
  simpleTypeDecl(N,"int"),!simpleTypeDecl(N,"unsigned"),signedInt(T).
simpleTypeDeclOf(N,T) :-
  simpleTypeDecl(N,"unsigned"),simpleTypeDecl(N,"int"),unsignedInt(T).


// ---------------------------------------------------------
// Concrete traces (program executions)
// ---------------------------------------------------------

.decl trace(trace:tid,stage:stg,from:cp,action:act,to:cp)

// First/init step in a trace.
trace(T,0,C1,A,C2) :-
  createTrace(T,C2),initActionTag(A),initCP(C1).

// Decl statements
declAction(T,I+1,V,L,Z),
trace(T,I+1,C1,A,C2) :-
  trace(T,I,_,_,C1),
  at(N,C1),isDecl(N),
  declActionTag(A),
  after(N,C2),
  varDeclOf(N,V,N2),
  initVarAddr(T,N2,V,L),
  evalInit(T,I,N2,Z).

// Skips/empty statements
trace(T,I+1,C1,A,C2) :-
  trace(T,I,_,_,C1),
  at(N,C1),isSkip(N),
  nopActionTag(A),
  after(N,C2).

// Assignments
assignAction(T,I+1,V,L,Z),
trace(T,I+1,C1,A,C2) :-
  trace(T,I,_,_,C1),
  at(N,C1),isAssignment(N),
  assignActionTag(A),
  after(N,C2),
  lhsLvalOf(N,V),
  rhsExprOf(N,RHS),
  env(T,I,V,L),
  eval(T,I,RHS,Z,_).

// Note which variables don't get an assignment
noAssignAction(T,I,V) :-
  assignAction(T,I,V1,_,_),
  progVar(V),V != V1.


// ---------------------------------------------------------
// Machine state/configuration
// ---------------------------------------------------------

.decl env(trace:tid,stage:stg,var:ident,addr:addr)
.decl store(trace:tid,stage:stg,addr:addr,val:val)

env(T,I,V,A) :- declAction(T,I,V,A,_).
env(T,I,V,A) :- assignAction(T,I,V,A,_).
env(T,I,V,A) :- noAssignAction(T,I,V),env(T,I-1,V,A).
env(T,I,V,A) :-
  trace(T,I,_,Act,_),!assignActionTag(Act),
  env(T,I-1,V,A).

store(T,I,A,Z) :- declAction(T,I,_,A,Z).
store(T,I,A,Z) :- assignAction(T,I,_,A,Z).
store(T,I,A,Z) :-
  assignAction(T,I,_,A1,_),A != A1,
  store(T,I-1,A,Z).
store(T,I,A,Z) :-
  trace(T,I,_,Act,_),!assignActionTag(Act),
  store(T,I-1,A,Z).

.decl lookupVar(trace:tid,stage:stg,var:ident,val:val)
lookupVar(T,I,V,Z) :- env(T,I,V,A),store(T,I,A,Z).


// ---------------------------------------------------------
// Initialization (of variables, etc)
// ---------------------------------------------------------

.decl initVarAddr(trace:tid,node:id,var:ident,addr:addr)

initVarAddr(T,N,V,autoinc()*B) :-
  createTrace(T,_),varDeclOf(N1,V,N),
  simpleTypeDeclOf(N1,K),unsignedInt(K),
  sizeOfUnsignedInt(B).

initVarAddr(T,N,V,autoinc()*B) :-
  createTrace(T,_),varDeclOf(N1,V,N),
  simpleTypeDeclOf(N1,K),signedInt(K),
  sizeOfInt(B).


// ---------------------------------------------------------
// Eval (expressions)
// ---------------------------------------------------------

.decl eval(trace:tid,stage:stg,node:id,val:val,typ:typ)  

// input() - unsigned int
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),inputExpr(N),userInput(T,N,Z),
  unsignedInt(K).

// input() - signed int
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),inputExpr(N),userInput(T,N,Z),
  signedInt(K).

// int lit - unsigned int
eval(T,I,N,W,K) :-
  trace(T,I,_,_,_),intLitExpr(N,Z), W = to_number(Z),
  unsignedInt(K).

// int lit - signed int
eval(T,I,N,W,K) :-
  trace(T,I,_,_,_),intLitExpr(N,Z), W = to_number(Z),
  signedInt(K).

// lookup var - unsigned int
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),lvalExpr(N,V),lookupVar(T,I,V,Z),
  varDeclOf(N1,V,_),simpleTypeDeclOf(N1,K),unsignedInt(K).

// lookup var - signed int
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),lvalExpr(N,V),lookupVar(T,I,V,Z),
  varDeclOf(N1,V,_),simpleTypeDeclOf(N1,K),signedInt(K).

// read a variable (lval-to-rval)
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),lvalToRvalExpr(N,N1),eval(T,I,N1,Z,K).

// signed-to-unsigned int conversion
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),signedToUnsignedIntExpr(N,N1),unsignedInt(K),
  maxUnsignedInt(L),
  eval(T,I,N1,Z1,K1),signedInt(K1),
  Z1 < 0, Z = Z1 + L.

// signed-to-unsigned int conversion
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),signedToUnsignedIntExpr(N,N1),unsignedInt(K),
  eval(T,I,N1,Z,K1),signedInt(K1),
  Z >= 0.

// unsigned-to-signed int conversion
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),unsignedToSignedIntExpr(N,N1),signedInt(K),
  eval(T,I,N1,Z1,K1),unsignedInt(K1),
  maxUnsignedInt(M),maxInt(L),
  Z1 > L,Z = Z1 - M.

// unsigned-to-signed int conversion
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),unsignedToSignedIntExpr(N,N1),signedInt(K),
  eval(T,I,N1,Z,K1),unsignedInt(K1),
  maxInt(L),
  Z <= L.

// negation unary op - signed int
eval(T,I,N,-Z,K) :-
  trace(T,I,_,_,_),
  unOpExpr(N,Op,E),isNegOp(Op),
  eval(T,I,E,Z,K),signedInt(K).

// + unsigned ints, no overflow
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),
  binOpExpr(N,Op,LHS,RHS),isAddOp(Op),
  eval(T,I,LHS,Z1,K),eval(T,I,RHS,Z2,K),
  Z = Z1 + Z2,
  unsignedInt(K),
  maxUnsignedInt(M),
  Z <= M.

// + unsigned ints, overflow
arithOverflow(T,I,N),
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),
  binOpExpr(N,Op,LHS,RHS),isAddOp(Op),
  eval(T,I,LHS,Z1,K),eval(T,I,RHS,Z2,K),
  Z3 = Z1 + Z2,
  unsignedInt(K),
  maxUnsignedInt(M),
  Z3 >= M,
  byteSize(W),sizeOfUnsignedInt(S),
  Z = Z3 % (S*W).

// + signed ints, no overflow
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),
  binOpExpr(N,Op,LHS,RHS),isAddOp(Op),
  eval(T,I,LHS,Z1,K),eval(T,I,RHS,Z2,K),
  Z = Z1 + Z2,
  signedInt(K),
  minInt(J),
  maxInt(M),
  J <= Z, Z <= M.

// + signed ints, oveflow below
arithOverflow(T,I,N),
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),
  binOpExpr(N,Op,LHS,RHS),isAddOp(Op),
  eval(T,I,LHS,Z1,K),eval(T,I,RHS,Z2,K),
  Z3 = Z1 + Z2,
  signedInt(K),
  minInt(J),
  maxInt(L),
  Z3 <= J,
  byteSize(W),sizeOfInt(S),
  M = 2^((W*S)-1),
  R = J - Z3,
  Z4 = R % M,
  Z = L - Z4.

// + signed ints, overflow above
arithOverflow(T,I,N),
eval(T,I,N,Z,K) :-
  trace(T,I,_,_,_),
  binOpExpr(N,Op,LHS,RHS),isAddOp(Op),
  eval(T,I,LHS,Z1,K),eval(T,I,RHS,Z2,K),
  Z3 = Z1 + Z2,
  signedInt(K),
  minInt(J),
  maxInt(L),
  Z3 > L,
  byteSize(W),sizeOfInt(S),
  M = 2^((W*S)-1),
  R = Z3 - L,
  Z4 = R % M,
  Z = J + Z4.


.decl evalInit(trace:tid,stage:stg,node:id,val:val)
evalInit(T,I,N,0) :- trace(T,I,_,_,_),nilInit(N).
evalInit(T,I,N,Z) :- isInit(N),eval(T,I,N,Z,_).


// ---------------------------------------------------------
// User interface
// ---------------------------------------------------------

.decl createTrace(trace:tid,start:cp)
.decl userInput(trace:tid,node:id,val:val)
